/**
 * Unpack packed html generated by the AssetServer html packer into a
 * DOM tree and a context object.  The context object returned has an
 * entry for each outlet marked in the packed html and one for "root".
 * The "root" outlet is recorded regardless of whether it is annotated
 * as such in the packed structure.
 *
 * NOTICE:
 * Copyright (c) 2011, Stella Laurenzo
 * Licensed freely for use under the terms of the AssetServer license.
 * Copy this function into your project as needed, but please preserve
 * this notice in source code (not necessarily code delivered to a user
 * agent).
 */
function unpackHtml(packed, interpolator, options) {
	if (!options) options={};
	var context={}, d=options.document||document;
	
	function makeElement(ary, parent) {
		var nameSpec=ary[0], 
			m=/^([^#\.]+)(#([^\.]*))?(\.(.*))?$/m.exec(nameSpec),
			elt,
			i,
			item,
			type;
		if (m) {
			elt=d.createElement(m[1]);
			if (m[3]) context[m[3]]=elt;
			if (m[5]) elt.className=m[5].replace('.',' ');
		} else {
			m=d.createElement(nameSpec);
		}
		
		if (parent) parent.appendChild(elt);
		for (i=1; i<ary.length; i++) {
			item=ary[i];
			// Switch based on what it is
			type=typeof item;
			if (item===0) {
				// Add space
				elt.appendChild(d.createTextNode(' '));
			} else if (item instanceof Array) {
				// Add child
				makeElement(item, elt);
			} else {
				// Treat as text
				item=String(item);
				if (item[0]==='@') {
					if (item[1]!=='@') {
						// Process attribute
						elt.setAttribute(item.substring(1), ary[++i]);
						continue;
					}
					// else unescape
					item=item.substring(1);
				}
				if (interpolator) item=interpolator(item);
				elt.appendChild(d.createTextNode(item));
			}
		}
		
		return elt;
	}
	
	context.root=makeElement(packed, null);
	return context;
}

/**
 * Return a function that will do string replacement against its argument,
 * replacing all occurences of ${...} with the corresponding value from
 * dict.  The pattern $${...} can be used as an escape.  If the token
 * is undefined, the substitution pattern is preserved.  If null, then an empty
 * string is replaced.
 */
function interpolator(dict) {
	return function(s) {
		return s.replace(/(\$)?\$\{([^\}]*)\}/gm, function(ss, esc, token) {
			if (esc) return ss.substring(1);
			var r=dict[token];
			if (r===undefined) return ss;
			if (r===null) return '';
			return r;
		});
	};
}

